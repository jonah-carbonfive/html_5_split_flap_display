<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>HTML5 boilerplate—all you really need…</title>
	<style type="text/css">
		#display {
			background-color: black;
		}
		#caches {
			background-color: black;
			display: block;
		}
	</style>
	<!--[if IE]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<script type="text/javascript" charset="utf-8">
	var SYMBOL_SET = ['AAAAA', 'BBBBB', 'CCCC', 'DD', 'Eˆ¨∂ß∂¬˚ßå∂', 'F∂ß∂¬˚ßå∂', 'G∂ß∂¬˚ßå∂', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
	var FLAP_BORDER_STYLE = 'gray';
	var FLAP_BACKGROUND_STYLE = 'black';
	var FLAP_TEXT_STYLE = 'white';
	
	var tester;
	
	function el(id) { return document.getElementById(id); }
	function each(a,f) { for (var i=0,l=a.length; i<l; i++) f(a[i],i); }
	
	function init() {
		var canvas = el('display');
		var context = canvas.getContext('2d')
		
		var font = "bold 36px Monospace";
		context.font = font;
		
		var cache_container = el('caches');
		
		var symbol_bounds = {'width': 0, 'height': 24};
		var symbol;
		for(symbol in SYMBOL_SET) {
			symbol_bounds['width'] = Math.max(symbol_bounds['width'], context.measureText(SYMBOL_SET[symbol]).width);
		}
		
		var symbol_set = new SymbolSet(SYMBOL_SET, symbol_bounds, font, cache_container);
		split_flap = new SplitFlap(symbol_set, context, {'x':100, 'y':100, 'width':symbol_bounds['width'] + 20, 'height':40});
		split_flap.draw();
		
		split_flap = new SplitFlap(symbol_set, context, {'x':100, 'y':200, 'width':symbol_bounds['width'] + 20, 'height':40});
		split_flap.current_symbol_index = 1;
		split_flap.draw();
		split_flap.flipToSymbolIndex(15);
		split_flap.draw();
		
		tester = split_flap;
		drawLoop();
	}
	function drawLoop() {
		setTimeout(function() {
			tester.tick();
			drawLoop();
		}, 30);
	}
	
	function SymbolSet(symbols, bounds, font, container) {
		this.symbols = symbols;
		this.bounds = bounds;
		
		this.symbols_canvas = document.createElement('canvas');
	    this.symbols_canvas.setAttribute('width', symbols.length * bounds['width']); 
		this.symbols_canvas.setAttribute('height', bounds['height']);
		container.appendChild(this.symbols_canvas);
		var context = this.symbols_canvas.getContext('2d');
		
		context.fillStyle = FLAP_TEXT_STYLE;
		context.strokeStyle = FLAP_TEXT_STYLE;
		context.font = font;
		context.textAligh = "center";
		var x = 0;
		var y = bounds['height'];
		var symbol;
		for(symbol in this.symbols) {
			context.fillText(this.symbols[symbol], x, y);
			x += bounds['width'];
		}
	}
	SymbolSet.prototype.drawSymbol = function(symbol_index, context, display_width, display_height) {
		context.save();

		//crop the symbol from the cache canvas
		var sx = this.bounds['width'] * symbol_index;
		var sy = 0;
		var sw = this.bounds['width'];
		var sh = this.bounds['height'];

		//center symbol in the display area
		context.textBaseline = "top";
		var dx = (display_width - sw)/2;
		var dy = (display_height - sh)/2;
		var dw = sw;
		var dh = sh;

		context.drawImage(this.symbols_canvas, sx, sy, sw, sh, dx, dy, dw, dh);
		context.restore();
	}
	SymbolSet.prototype.subsequentSymbolIndex = function(symbol_index) {
		if (symbol_index >= this.symbols.length ) {
			return 0;
		}
		return symbol_index + 1;
	}
	
	function SplitFlap(symbol_set, context, bounds) {
		this.symbol_set = symbol_set;
		this.current_symbol_index = 0;
		this.goal_symbol_index = 0;
		this.context = context;
		this.bounds = bounds;
		this.animation_progress = 100;
		this.flip_animation_duration = 1000;
	}
	SplitFlap.prototype.draw = function() {
		this.context.save();
		this.context.fillStyle = FLAP_TEXT_STYLE;
		this.context.strokeStyle = FLAP_TEXT_STYLE;
		this.context.transform(1,0, 0,1, this.bounds['x'],this.bounds['y']);
		this.drawTopFlap();
		this.context.transform(1,0, 0,1, 0,this.bounds['height']/2);
		this.drawBottomFlap();
		this.context.restore();
	}
	SplitFlap.prototype.drawTopFlap = function() {
		var drawFlapOutline = function(context, bounds) {
			corner_radius = Math.min(Math.min(10, bounds['width']), bounds['height']);
			context.beginPath();
			context.moveTo(0, bounds['height']/2);
			context.lineTo(0, corner_radius);
			context.bezierCurveTo(0, 0, 0, 0, corner_radius, 0);
			context.lineTo(bounds['width'] - corner_radius, 0);
			context.bezierCurveTo(bounds['width'], 0, bounds['width'], 0, bounds['width'], corner_radius);
			context.lineTo(bounds['width'], bounds['height']/2);
			context.closePath();
			
			context.fillStyle = FLAP_BACKGROUND_STYLE;
			context.strokeStyle = FLAP_BORDER_STYLE;
			context.fill();
			context.stroke();
			context.clip();
		}
		
		this.context.save();
		this.context.clearRect(0, 0, this.bounds['width'], this.bounds['height']/2);
		
		if (this.animation_progress > 0) {
			this.context.save();
			drawFlapOutline(this.context, this.bounds);
			this.context.transform(1,0, 0,1, 0,this.bounds['height'] / 4);
			this.symbol_set.drawSymbol(this.symbol_set.subsequentSymbolIndex(this.current_symbol_index), this.context, this.bounds['width'], this.bounds['height']/2);
			this.context.restore();
		}
		
		if (this.animation_progress <= 50) {
			this.context.save();
			var vertical_scale_factor = (50-this.animation_progress)/50.0
			this.context.transform(1,0, 0,vertical_scale_factor, 0,this.bounds['height']/2 * (1-vertical_scale_factor));
			drawFlapOutline(this.context, this.bounds);
			this.context.transform(1,0, 0,1, 0,this.bounds['height'] / 4);
			this.symbol_set.drawSymbol(this.current_symbol_index, this.context, this.bounds['width'], this.bounds['height']/2);
			this.context.restore();
		}
		this.context.restore();
	}
	SplitFlap.prototype.drawBottomFlap = function() {
		var drawFlapOutline = function(context, bounds) {
			corner_radius = Math.min(Math.min(10, bounds['width']), bounds['height']);
			context.beginPath();
			context.moveTo(0, 0);
			context.lineTo(bounds['width'], 0);
			context.lineTo(bounds['width'], bounds['height']/2 - corner_radius);
			context.bezierCurveTo(bounds['width'], bounds['height']/2, bounds['width'], bounds['height']/2, bounds['width'] - corner_radius, bounds['height']/2);
			context.lineTo(corner_radius, bounds['height']/2);
			context.bezierCurveTo(0, bounds['height']/2, 0, bounds['height']/2, 0, bounds['height']/2 - corner_radius);
			context.closePath();
			
			context.fillStyle = FLAP_BACKGROUND_STYLE;
			context.strokeStyle = FLAP_BORDER_STYLE;
			context.fill();
			context.stroke();
			context.clip();
		}
		
		this.context.save();
		this.context.clearRect(0, 0, this.bounds['width'], this.bounds['height']/2);

		// DEBUG: uncomment to offset the top and bottom flaps
		// this.context.transform(1,0, 0,1, 0,this.bounds['height']);		

		this.context.save();
		drawFlapOutline(this.context, this.bounds);
		this.context.transform(1,0, 0,1, 0,-this.bounds['height'] / 4);
		this.symbol_set.drawSymbol(this.current_symbol_index, this.context, this.bounds['width'], this.bounds['height']/2);
		this.context.restore();

		
		if (this.animation_progress >= 50) {
			this.context.save();
			var vertical_scale_factor = (this.animation_progress - 50)/50.0;
			this.context.transform(1,0, 0,vertical_scale_factor, 0,0);
			drawFlapOutline(this.context, this.bounds);
			this.context.transform(1,0, 0,1, 0,-this.bounds['height'] / 4);
			this.symbol_set.drawSymbol(this.symbol_set.subsequentSymbolIndex(this.current_symbol_index), this.context, this.bounds['width'], this.bounds['height']/2);
			this.context.restore();
		}
		
		this.context.restore();
	}
	SplitFlap.prototype.jumpToSymbolIndex = function(symbol_index) {
		this.current_symbol_index = symbol_index;
		this.goal_symbol_index = symbol_index;
		this.animation_progress = 100;
		this.tick();
	}
	SplitFlap.prototype.flipToSymbolIndex = function(symbol_index) {
		this.goal_symbol_index = symbol_index;
		this.animation_progress = 0;
		this.tick();
	}
	SplitFlap.prototype.tick = function(elapsed_millis) {
		if (this.current_symbol_index != this.goal_symbol_index) {
			this.animation_progress = (this.animation_progress + 10);
			if (this.animation_progress > 100) {
				this.current_symbol_index = this.symbol_set.subsequentSymbolIndex(this.current_symbol_index);
				this.animation_progress = 0;
			}
			this.draw();
		}
	}
	SplitFlap.prototype.animating = function() {
		return this.animation_progress < 100;
	}
	</script>
</head>

<body onload="init()">
	<canvas id="display" width="1000" height="650"></canvas>
	<div id="caches"></div>
	<div id="credits">
		<a href="#"></a>
	</div>
</body>

</html>